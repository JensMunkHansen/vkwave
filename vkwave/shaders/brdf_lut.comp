#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, rgba8) writeonly uniform image2D u_lut;

layout(push_constant) uniform PC {
  uint resolution;
  uint sampleCount;
};

#define MATH_PI 3.1415926535897932384626433832795

float radicalInverse_VdC(uint bits)
{
  bits = (bits << 16u) | (bits >> 16u);
  bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
  bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
  bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
  bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
  return float(bits) * 2.3283064365386963e-10;
}

vec2 hammersley2d(uint i, uint N)
{
  return vec2(float(i) / float(N), radicalInverse_VdC(i));
}

// GGX NDF
float D_GGX(float NdotH, float alpha)
{
  float a = NdotH * alpha;
  float k = alpha / (1.0 - NdotH * NdotH + a * a);
  return k * k * (1.0 / MATH_PI);
}

// Smith-GGX correlated visibility (Filament / Khronos)
float V_SmithGGXCorrelated(float NoV, float NoL, float roughness)
{
  float a2 = pow(roughness, 4.0);
  float GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);
  float GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);
  return 0.5 / (GGXV + GGXL);
}

void main()
{
  uvec2 pos = gl_GlobalInvocationID.xy;
  if (pos.x >= resolution || pos.y >= resolution)
    return;

  float NdotV = (float(pos.x) + 0.5) / float(resolution);
  float roughness = (float(pos.y) + 0.5) / float(resolution);

  NdotV = max(NdotV, 0.001);
  roughness = max(roughness, 0.001);

  vec3 V = vec3(sqrt(1.0 - NdotV * NdotV), 0.0, NdotV);
  vec3 N = vec3(0.0, 0.0, 1.0);

  float alpha = roughness * roughness;

  float A = 0.0;
  float B = 0.0;

  for (uint i = 0; i < sampleCount; ++i)
  {
    vec2 xi = hammersley2d(i, sampleCount);

    // GGX importance sampling
    float cosTheta = clamp(sqrt((1.0 - xi.y) / (1.0 + (alpha * alpha - 1.0) * xi.y)), 0.0, 1.0);
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    float phi = 2.0 * MATH_PI * xi.x;

    vec3 H = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
    vec3 L = normalize(2.0 * dot(V, H) * H - V);

    float NdotL = clamp(L.z, 0.0, 1.0);
    float NdotH = clamp(H.z, 0.0, 1.0);
    float VdotH = clamp(dot(V, H), 0.0, 1.0);

    if (NdotL > 0.0)
    {
      // Khronos reference: V_pdf = V * VdotH * NdotL / NdotH
      // The 4.0 factor is pulled out and applied after the loop
      float V_pdf = V_SmithGGXCorrelated(NdotV, NdotL, roughness) * VdotH * NdotL / NdotH;
      float Fc = pow(1.0 - VdotH, 5.0);

      A += (1.0 - Fc) * V_pdf;
      B += Fc * V_pdf;
    }
  }

  // The 4.0 factor from Jacobian (Khronos reference)
  A = 4.0 * A / float(sampleCount);
  B = 4.0 * B / float(sampleCount);

  imageStore(u_lut, ivec2(pos), vec4(A, B, 0.0, 1.0));
}
